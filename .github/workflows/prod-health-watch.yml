name: Production Health Watch

on:
  schedule:
    - cron: "*/15 * * * *" # Every 15 minutes
  workflow_dispatch: # Allow manual triggering

jobs:
  health-check:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' # Only run on main branch

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Probe Production Readiness
        id: readiness
        run: |
          python -c "
          import requests
          import sys
          import json
          from datetime import datetime

          PROD_URL = '${{ secrets.PRODUCTION_URL }}'
          if not PROD_URL:
              print('‚ö†Ô∏è  PRODUCTION_URL secret not set, skipping health check')
              sys.exit(0)

          print(f'üîç Checking production health at {PROD_URL}')

          try:
              # Check version endpoint
              resp = requests.get(f'{PROD_URL}/api/version', timeout=10)
              if resp.status_code != 200:
                  print(f'‚ùå Version endpoint failed: {resp.status_code}')
                  sys.exit(1)

              version_data = resp.json()
              print(f'‚úÖ Version endpoint OK: {version_data.get(\"service\", \"unknown\")}')

              # Check metrics endpoint
              resp = requests.get(f'{PROD_URL}/api/metrics', timeout=15)
              if resp.status_code != 200:
                  print(f'‚ùå Metrics endpoint failed: {resp.status_code}')
                  sys.exit(1)

              metrics_data = resp.json()
              print(f'‚úÖ Metrics endpoint OK')

              # Basic health indicators
              if 'system' in metrics_data:
                  system = metrics_data['system']
                  if 'memory_usage_mb' in system:
                      memory_mb = system['memory_usage_mb']
                      if memory_mb > 1000:  # Alert if over 1GB
                          print(f'‚ö†Ô∏è  High memory usage: {memory_mb}MB')
                      else:
                          print(f'‚úÖ Memory usage OK: {memory_mb}MB')

              print(f'üéâ Production health check passed at {datetime.now().isoformat()}')

          except requests.exceptions.Timeout:
              print('‚ùå Production service timeout')
              sys.exit(1)
          except requests.exceptions.ConnectionError:
              print('‚ùå Cannot connect to production service')
              sys.exit(1)
          except Exception as e:
              print(f'‚ùå Health check failed: {e}')
              sys.exit(1)
          "

      - name: Run Contract Tests Against Production
        if: success()
        run: |
          if [ -n "${{ secrets.PRODUCTION_URL }}" ]; then
            echo "üß™ Running contract tests against production"
            python tests/test_manifest_contract.py "${{ secrets.PRODUCTION_URL }}"
          else
            echo "‚ö†Ô∏è  PRODUCTION_URL not set, skipping contract tests"
          fi

      - name: Create Issue on Failure
        if: failure()
        uses: actions/github-script@v6
        with:
          script: |
            const title = `üö® Production Health Check Failed - ${new Date().toISOString()}`;
            const body = `
            ## Production Health Check Failure

            **Time:** ${new Date().toISOString()}
            **Workflow:** ${context.workflow}
            **Run ID:** ${context.runId}
            **Run URL:** ${context.payload.repository.html_url}/actions/runs/${context.runId}

            ### Details
            The automated production health check has detected an issue with the live service.

            ### Next Steps
            1. Check the workflow logs for specific error details
            2. Verify production service status
            3. Check monitoring dashboards
            4. Investigate and resolve the issue
            5. Close this issue once resolved

            ### Auto-generated
            This issue was automatically created by the Production Health Watch workflow.
            `;

            // Check if there's already an open issue for production health
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'production-health,automated'
            });

            if (issues.data.length === 0) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['production-health', 'automated', 'urgent']
              });
              console.log('Created new production health issue');
            } else {
              console.log('Production health issue already exists, not creating duplicate');
            }

  soak-test:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    needs: health-check

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Soak Test - Multiple Requests
        run: |
          python -c "
          import requests
          import time
          import sys
          from concurrent.futures import ThreadPoolExecutor

          PROD_URL = '${{ secrets.PRODUCTION_URL }}'
          if not PROD_URL:
              print('‚ö†Ô∏è  PRODUCTION_URL not set, skipping soak test')
              sys.exit(0)

          def make_request(endpoint):
              try:
                  resp = requests.get(f'{PROD_URL}{endpoint}', timeout=10)
                  return resp.status_code == 200
              except:
                  return False

          print('üîÑ Running soak test with multiple concurrent requests')

          endpoints = ['/api/version', '/api/metrics'] * 5  # 10 total requests

          with ThreadPoolExecutor(max_workers=3) as executor:
              results = list(executor.map(make_request, endpoints))

          success_rate = sum(results) / len(results)
          print(f'üìä Soak test success rate: {success_rate:.1%} ({sum(results)}/{len(results)})')

          if success_rate < 0.9:  # 90% success threshold
              print('‚ùå Soak test failed - success rate below 90%')
              sys.exit(1)
          else:
              print('‚úÖ Soak test passed')
          "
