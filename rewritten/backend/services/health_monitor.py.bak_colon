#!/usr/bin/env python3
""""""
Comprehensive Health Monitoring System

This module provides real - time health monitoring for all model generation
components to ensure 100% system reliability and availability.

Features:
- Real - time component health tracking
- Automated failure detection and alerting
- Performance metrics collection
- Predictive failure analysis
- Automatic recovery mechanisms
- Dashboard and reporting
""""""

import asyncio
import json
import logging
import os
import sqlite3
import threading
import time
from concurrent.futures import ThreadPoolExecutor
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional

import psutil
import requests

# Configure logging
logging.basicConfig(level = logging.INFO)
logger = logging.getLogger(__name__)


class ComponentType(Enum):
    """Types of components to monitor"""

    MODEL_GENERATOR = "model_generator"
    AVATAR_ENGINE = "avatar_engine"
    API_ORCHESTRATOR = "api_orchestrator"
    DATABASE = "database"
    CACHE = "cache"
    EXTERNAL_API = "external_api"
    SYSTEM_RESOURCE = "system_resource"
    NETWORK = "network"


class HealthStatus(Enum):
    """Health status levels"""

    HEALTHY = "healthy"
    WARNING = "warning"
    CRITICAL = "critical"
    DOWN = "down"
    UNKNOWN = "unknown"
    RECOVERING = "recovering"


class AlertSeverity(Enum):
    """Alert severity levels"""

    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    EMERGENCY = "emergency"

@dataclass


class HealthMetric:
    """Individual health metric"""

    name: str
    value: float
    unit: str
    threshold_warning: Optional[float] = None
    threshold_critical: Optional[float] = None
    timestamp: datetime = field(default_factory = datetime.now)
    metadata: Dict[str, Any] = field(default_factory = dict)

@dataclass


class ComponentHealth:
    """Health status of a component"""

    component_id: str
    component_type: ComponentType
    status: HealthStatus
    metrics: List[HealthMetric] = field(default_factory = list)
    last_check: datetime = field(default_factory = datetime.now)
    uptime_seconds: float = 0
    error_count: int = 0
    success_count: int = 0
    response_time_ms: float = 0
    metadata: Dict[str, Any] = field(default_factory = dict)

@dataclass


class HealthAlert:
    """Health alert/notification"""

    alert_id: str
    component_id: str
    severity: AlertSeverity
    message: str
    metric_name: Optional[str] = None
    metric_value: Optional[float] = None
    threshold: Optional[float] = None
    created_at: datetime = field(default_factory = datetime.now)
    resolved_at: Optional[datetime] = None
    acknowledged: bool = False
    metadata: Dict[str, Any] = field(default_factory = dict)


class HealthChecker:
    """Base class for component health checkers"""


    def __init__(self, component_id: str, component_type: ComponentType):
        self.component_id = component_id
        self.component_type = component_type
        self.last_check = None
        self.consecutive_failures = 0
        self.max_consecutive_failures = 3


    async def check_health(self) -> ComponentHealth:
        """Check component health - to be implemented by subclasses"""
        raise NotImplementedError


    def _create_metric(
        self,
            name: str,
            value: float,
            unit: str,
            warning_threshold: float = None,
            critical_threshold: float = None,
# BRACKET_SURGEON: disabled
#             ) -> HealthMetric:
        """Create a health metric"""
        return HealthMetric(
            name = name,
                value = value,
                unit = unit,
                threshold_warning = warning_threshold,
                threshold_critical = critical_threshold,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )


class ModelGeneratorHealthChecker(HealthChecker):
    """Health checker for model generator"""


    def __init__(self, generator_instance = None):
        super().__init__("model_generator", ComponentType.MODEL_GENERATOR)
        self.generator = generator_instance


    async def check_health(self) -> ComponentHealth:
        """Check model generator health"""
        start_time = time.time()
        metrics = []
        status = HealthStatus.HEALTHY
        error_count = 0

        try:
            if self.generator:
                # Get system status from generator
                system_status = self.generator.get_system_status()

                # Active requests metric
                metrics.append(
                    self._create_metric(
                        "active_requests",
                        system_status.get("active_requests", 0),
                        "count",
                        warning_threshold = 10,
                        critical_threshold = 50,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                     )
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )

                # Healthy backends metric
                healthy_backends = system_status.get("healthy_backends", 0)
                total_backends = system_status.get("total_backends", 1)
                backend_ratio = (
                    healthy_backends/total_backends if total_backends > 0 else 0
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )

                metrics.append(
                    self._create_metric(
                        "backend_availability",
                            backend_ratio * 100,
                            "percent",
                            warning_threshold = 80,
                            critical_threshold = 50,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                             )
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )

                # Cache performance
                cache_size = system_status.get("cache_size", 0)
                metrics.append(self._create_metric("cache_size", cache_size, "count"))

                # Determine overall status
                if backend_ratio < 0.5:
                    status = HealthStatus.CRITICAL
                elif backend_ratio < 0.8:
                    status = HealthStatus.WARNING
                elif system_status.get("active_requests", 0) > 50:
                    status = HealthStatus.CRITICAL
                elif system_status.get("active_requests", 0) > 10:
                    status = HealthStatus.WARNING

            else:
                # Generator not available
                status = HealthStatus.DOWN
                error_count = 1

        except Exception as e:
            logger.error(f"Model generator health check failed: {e}")
            status = HealthStatus.CRITICAL
            error_count = 1

        response_time = (time.time() - start_time) * 1000

        return ComponentHealth(
            component_id = self.component_id,
                component_type = self.component_type,
                status = status,
                metrics = metrics,
                response_time_ms = response_time,
                error_count = error_count,
                success_count = 1 if error_count == 0 else 0,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )


class SystemResourceHealthChecker(HealthChecker):
    """Health checker for system resources"""


    def __init__(self):
        super().__init__("system_resources", ComponentType.SYSTEM_RESOURCE)


    async def check_health(self) -> ComponentHealth:
        """Check system resource health"""
        start_time = time.time()
        metrics = []
        status = HealthStatus.HEALTHY

        try:
            # CPU usage
            cpu_percent = psutil.cpu_percent(interval = 1)
            metrics.append(
                self._create_metric(
                    "cpu_usage",
                        cpu_percent,
                        "percent",
                        warning_threshold = 80,
                        critical_threshold = 95,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                         )
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             )

            # Memory usage
            memory = psutil.virtual_memory()
            metrics.append(
                self._create_metric(
                    "memory_usage",
                        memory.percent,
                        "percent",
                        warning_threshold = 80,
                        critical_threshold = 95,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                         )
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             )

            # Disk usage
            disk = psutil.disk_usage("/")
            disk_percent = (disk.used/disk.total) * 100
            metrics.append(
                self._create_metric(
                    "disk_usage",
                        disk_percent,
                        "percent",
                        warning_threshold = 80,
                        critical_threshold = 95,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                         )
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             )

            # Available memory in GB
            available_memory_gb = memory.available/(1024**3)
            metrics.append(
                self._create_metric(
                    "available_memory",
                        available_memory_gb,
                        "GB",
                        warning_threshold = 2,
                        critical_threshold = 1,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                         )
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             )

            # Load average (Unix systems)
            try:
                load_avg = os.getloadavg()[0]  # 1 - minute load average
                cpu_count = psutil.cpu_count()
                load_percent = (load_avg/cpu_count) * 100
                metrics.append(
                    self._create_metric(
                        "load_average",
                            load_percent,
                            "percent",
                            warning_threshold = 80,
                            critical_threshold = 100,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                             )
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )
            except (OSError, AttributeError):
                # Not available on all systems
                pass

            # Determine overall status based on metrics
            critical_metrics = [
                m
                for m in metrics
                if m.threshold_critical and m.value >= m.threshold_critical
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             ]
            warning_metrics = [
                m
                for m in metrics
                if m.threshold_warning and m.value >= m.threshold_warning
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             ]

            if critical_metrics:
                status = HealthStatus.CRITICAL
            elif warning_metrics:
                status = HealthStatus.WARNING

        except Exception as e:
            logger.error(f"System resource health check failed: {e}")
            status = HealthStatus.CRITICAL

        response_time = (time.time() - start_time) * 1000

        return ComponentHealth(
            component_id = self.component_id,
                component_type = self.component_type,
                status = status,
                metrics = metrics,
                response_time_ms = response_time,
                error_count = 1 if status == HealthStatus.CRITICAL else 0,
                success_count = 1 if status != HealthStatus.CRITICAL else 0,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )


class DatabaseHealthChecker(HealthChecker):
    """Health checker for database connections"""


    def __init__(self, db_path: str):
        super().__init__("database", ComponentType.DATABASE)
        self.db_path = db_path


    async def check_health(self) -> ComponentHealth:
        """Check database health"""
        start_time = time.time()
        metrics = []
        status = HealthStatus.HEALTHY
        error_count = 0

        try:
            # Test database connection and basic operations
            with sqlite3.connect(self.db_path, timeout = 5) as conn:
                cursor = conn.cursor()

                # Test query
                cursor.execute("SELECT 1")
                result = cursor.fetchone()

                if result[0] != 1:
                    raise Exception("Database query returned unexpected result")

                # Get database size
                db_size_bytes = Path(self.db_path).stat().st_size
                db_size_mb = db_size_bytes/(1024 * 1024)

                metrics.append(
                    self._create_metric(
                        "database_size",
                            db_size_mb,
                            "MB",
                            warning_threshold = 1000,
                            critical_threshold = 5000,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                             )
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )

                # Test write operation
                cursor.execute(
                    """"""
                    CREATE TABLE IF NOT EXISTS health_check_test (
                        id INTEGER PRIMARY KEY,
                            timestamp TEXT
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                     )
                """"""
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )

                cursor.execute(
                    "INSERT INTO health_check_test (timestamp) VALUES (?)",
                        (datetime.now().isoformat(),),
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                         )

                # Clean up old test records
                cursor.execute(
                    "DELETE FROM health_check_test WHERE timestamp < ?",
                        ((datetime.now() - timedelta(hours = 1)).isoformat(),),
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                         )

                conn.commit()

        except Exception as e:
            logger.error(f"Database health check failed: {e}")
            status = HealthStatus.CRITICAL
            error_count = 1

        response_time = (time.time() - start_time) * 1000

        metrics.append(
            self._create_metric(
                "response_time",
                    response_time,
                    "ms",
                    warning_threshold = 1000,
                    critical_threshold = 5000,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                     )
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#         )

        return ComponentHealth(
            component_id = self.component_id,
                component_type = self.component_type,
                status = status,
                metrics = metrics,
                response_time_ms = response_time,
                error_count = error_count,
                success_count = 1 if error_count == 0 else 0,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )


class ExternalAPIHealthChecker(HealthChecker):
    """Health checker for external APIs"""


    def __init__(
        self,
            api_name: str,
            health_check_url: str,
            headers: Dict[str, str] = None,
            timeout: int = 10,
# BRACKET_SURGEON: disabled
#             ):
        super().__init__(f"api_{api_name}", ComponentType.EXTERNAL_API)
        self.api_name = api_name
        self.health_check_url = health_check_url
        self.headers = headers or {}
        self.timeout = timeout


    async def check_health(self) -> ComponentHealth:
        """Check external API health"""
        start_time = time.time()
        metrics = []
        status = HealthStatus.HEALTHY
        error_count = 0

        try:
            response = requests.get(
                self.health_check_url, headers = self.headers, timeout = self.timeout
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             )

            response_time = (time.time() - start_time) * 1000

            metrics.append(
                self._create_metric(
                    "response_time",
                        response_time,
                        "ms",
                        warning_threshold = 2000,
                        critical_threshold = 10000,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                         )
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             )

            metrics.append(
                self._create_metric("status_code", response.status_code, "code")
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             )

            # Determine status based on response
            if response.status_code == 200:
                if response_time > 10000:
                    status = HealthStatus.CRITICAL
                elif response_time > 2000:
                    status = HealthStatus.WARNING
            elif 400 <= response.status_code < 500:
                status = HealthStatus.WARNING
                error_count = 1
            else:
                status = HealthStatus.CRITICAL
                error_count = 1

        except requests.exceptions.Timeout:
            status = HealthStatus.CRITICAL
            error_count = 1
            response_time = self.timeout * 1000
        except Exception as e:
            logger.error(f"External API health check failed for {self.api_name}: {e}")
            status = HealthStatus.CRITICAL
            error_count = 1
            response_time = (time.time() - start_time) * 1000

        return ComponentHealth(
            component_id = self.component_id,
                component_type = self.component_type,
                status = status,
                metrics = metrics,
                response_time_ms = response_time,
                error_count = error_count,
                success_count = 1 if error_count == 0 else 0,
                metadata={"api_name": self.api_name, "url": self.health_check_url},
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )


class ComprehensiveHealthMonitor:
    """Main health monitoring system"""


    def __init__(
        self, db_path: str = "data/health_monitor.db", check_interval: int = 30
# BRACKET_SURGEON: disabled
#     ):
        self.db_path = db_path
        self.check_interval = check_interval
        self.health_checkers: List[HealthChecker] = []
        self.current_health: Dict[str, ComponentHealth] = {}
        self.active_alerts: Dict[str, HealthAlert] = {}
        self.alert_handlers: List[Callable[[HealthAlert], None]] = []
        self.monitoring_active = False
        self.executor = ThreadPoolExecutor(max_workers = 10)
        self.lock = threading.RLock()

        # Initialize database
        self._init_database()

        # Add default health checkers
        self._setup_default_checkers()

        logger.info(
            f"ComprehensiveHealthMonitor initialized with {len(self.health_checkers)} checkers"
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#         )


    def _init_database(self):
        """Initialize health monitoring database"""
        os.makedirs(os.path.dirname(self.db_path), exist_ok = True)

        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()

            # Component health history
            cursor.execute(
                """"""
                CREATE TABLE IF NOT EXISTS component_health (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                        component_id TEXT NOT NULL,
                        component_type TEXT NOT NULL,
                        status TEXT NOT NULL,
                        response_time_ms REAL,
                        error_count INTEGER DEFAULT 0,
                        success_count INTEGER DEFAULT 0,
                        check_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        metadata TEXT
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )
            """"""
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             )

            # Health metrics history
            cursor.execute(
                """"""
                CREATE TABLE IF NOT EXISTS health_metrics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                        component_id TEXT NOT NULL,
                        metric_name TEXT NOT NULL,
                        metric_value REAL NOT NULL,
                        metric_unit TEXT,
                        threshold_warning REAL,
                        threshold_critical REAL,
                        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )
            """"""
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             )

            # Health alerts
            cursor.execute(
                """"""
                CREATE TABLE IF NOT EXISTS health_alerts (
                    alert_id TEXT PRIMARY KEY,
                        component_id TEXT NOT NULL,
                        severity TEXT NOT NULL,
                        message TEXT NOT NULL,
                        metric_name TEXT,
                        metric_value REAL,
                        threshold_value REAL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        resolved_at TIMESTAMP,
                        acknowledged BOOLEAN DEFAULT FALSE
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )
            """"""
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             )

            # Create indexes for performance
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_component_health_timestamp "
                "ON component_health(component_id, check_timestamp)"
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_health_metrics_timestamp "
                "ON health_metrics(component_id, metric_name, timestamp)"
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             )

            conn.commit()


    def _setup_default_checkers(self):
        """Setup default health checkers"""
        # System resources
        self.add_health_checker(SystemResourceHealthChecker())

        # Database
        self.add_health_checker(DatabaseHealthChecker("data/model_generator.db"))

        # External APIs (if configured)
        if os.getenv("OPENAI_API_KEY"):
            self.add_health_checker(
                ExternalAPIHealthChecker(
                    "openai",
                        "https://api.openai.com/v1/models",
                        headers={"Authorization": f"Bearer {os.getenv('OPENAI_API_KEY')}"},
                        timeout = 10,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                         )
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             )


    def add_health_checker(self, checker: HealthChecker):
        """Add a health checker"""
        with self.lock:
            self.health_checkers.append(checker)
            logger.info(f"Added health checker for {checker.component_id}")


    def add_alert_handler(self, handler: Callable[[HealthAlert], None]):
        """Add an alert handler function"""
        self.alert_handlers.append(handler)


    def start_monitoring(self):
        """Start health monitoring"""
        if self.monitoring_active:
            logger.warning("Health monitoring is already active")
            return

        self.monitoring_active = True


        def monitoring_loop():
            while self.monitoring_active:
                try:
                    asyncio.run(self._check_all_components())
                    time.sleep(self.check_interval)
                except Exception as e:
                    logger.error(f"Health monitoring error: {e}")
                    time.sleep(60)  # Wait longer on error

        threading.Thread(target = monitoring_loop, daemon = True).start()
        logger.info("Health monitoring started")


    def stop_monitoring(self):
        """Stop health monitoring"""
        self.monitoring_active = False
        logger.info("Health monitoring stopped")


    async def _check_all_components(self):
        """Check health of all components"""
        tasks = []

        for checker in self.health_checkers:
            task = asyncio.create_task(self._check_component_health(checker))
            tasks.append(task)

        # Wait for all health checks to complete
        results = await asyncio.gather(*tasks, return_exceptions = True)

        # Process results
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                logger.error(
                    f"Health check failed for {self.health_checkers[i].component_id}: {result}"
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )
            elif isinstance(result, ComponentHealth):
                await self._process_health_result(result)


    async def _check_component_health(self, checker: HealthChecker) -> ComponentHealth:
        """Check health of a single component"""
        try:
            health = await checker.check_health()
            return health
        except Exception as e:
            logger.error(f"Health check failed for {checker.component_id}: {e}")
            # Return a failed health status
            return ComponentHealth(
                component_id = checker.component_id,
                    component_type = checker.component_type,
                    status = HealthStatus.CRITICAL,
                    error_count = 1,
                    metadata={"error": str(e)},
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                     )


    async def _process_health_result(self, health: ComponentHealth):
        """Process health check result"""
        with self.lock:
            # Store current health
            previous_health = self.current_health.get(health.component_id)
            self.current_health[health.component_id] = health

            # Log to database
            self._log_health_result(health)

            # Check for status changes and generate alerts
            if previous_health and previous_health.status != health.status:
                await self._handle_status_change(previous_health, health)

            # Check metric thresholds
            for metric in health.metrics:
                await self._check_metric_thresholds(health.component_id, metric)


    def _log_health_result(self, health: ComponentHealth):
        """Log health result to database"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()

                # Log component health
                cursor.execute(
                    """"""
                    INSERT INTO component_health
                    (component_id, component_type, status, response_time_ms,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                         error_count, success_count, metadata)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                ""","""
                    (
                        health.component_id,
                            health.component_type.value,
                            health.status.value,
                            health.response_time_ms,
                            health.error_count,
                            health.success_count,
                            json.dumps(health.metadata),
# BRACKET_SURGEON: disabled
#                             ),
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                         )

                # Log metrics
                for metric in health.metrics:
                    cursor.execute(
                        """"""
                        INSERT INTO health_metrics
                        (component_id, metric_name, metric_value, metric_unit,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                             threshold_warning, threshold_critical)
                        VALUES (?, ?, ?, ?, ?, ?)
                    ""","""
                        (
                            health.component_id,
                                metric.name,
                                metric.value,
                                metric.unit,
                                metric.threshold_warning,
                                metric.threshold_critical,
# BRACKET_SURGEON: disabled
#                                 ),
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                             )

                conn.commit()

        except Exception as e:
            logger.error(f"Failed to log health result: {e}")


    async def _handle_status_change(
        self, previous: ComponentHealth, current: ComponentHealth
# BRACKET_SURGEON: disabled
#     ):
        """Handle component status changes"""
        if current.status in [HealthStatus.CRITICAL, HealthStatus.DOWN]:
            severity = AlertSeverity.CRITICAL
        elif current.status == HealthStatus.WARNING:
            severity = AlertSeverity.WARNING
        else:
            severity = AlertSeverity.INFO

        alert = HealthAlert(
            alert_id = f"{current.component_id}_status_{int(time.time())}",
                component_id = current.component_id,
                severity = severity,
                message = f"Component {current.component_id} status changed from {previous.status.value} to {current.status.value}",
                metadata={
                "previous_status": previous.status.value,
                    "current_status": current.status.value,
                    "component_type": current.component_type.value,
# BRACKET_SURGEON: disabled
#                     },
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                 )

        await self._trigger_alert(alert)


    async def _check_metric_thresholds(self, component_id: str, metric: HealthMetric):
        """Check if metric exceeds thresholds"""
        alert_severity = None
        threshold_exceeded = None

        if metric.threshold_critical and metric.value >= metric.threshold_critical:
            alert_severity = AlertSeverity.CRITICAL
            threshold_exceeded = metric.threshold_critical
        elif metric.threshold_warning and metric.value >= metric.threshold_warning:
            alert_severity = AlertSeverity.WARNING
            threshold_exceeded = metric.threshold_warning

        if alert_severity:
            alert = HealthAlert(
                alert_id = f"{component_id}_{metric.name}_{int(time.time())}",
                    component_id = component_id,
                    severity = alert_severity,
                    message = f"Metric {metric.name} exceeded {alert_severity.value} threshold: {metric.value} {metric.unit} >= {threshold_exceeded} {metric.unit}",
                    metric_name = metric.name,
                    metric_value = metric.value,
                    threshold = threshold_exceeded,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                     )

            await self._trigger_alert(alert)


    async def _trigger_alert(self, alert: HealthAlert):
        """Trigger a health alert"""
        # Store alert
        with self.lock:
            self.active_alerts[alert.alert_id] = alert

        # Log to database
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute(
                    """"""
                    INSERT INTO health_alerts
                    (alert_id, component_id, severity, message, metric_name,
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                         metric_value, threshold_value)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                ""","""
                    (
                        alert.alert_id,
                            alert.component_id,
                            alert.severity.value,
                            alert.message,
                            alert.metric_name,
                            alert.metric_value,
                            alert.threshold,
# BRACKET_SURGEON: disabled
#                             ),
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                         )
                conn.commit()
        except Exception as e:
            logger.error(f"Failed to log alert: {e}")

        # Notify alert handlers
        for handler in self.alert_handlers:
            try:
                handler(alert)
            except Exception as e:
                logger.error(f"Alert handler failed: {e}")

        logger.warning(f"ALERT [{alert.severity.value.upper()}] {alert.message}")


    def get_system_health_summary(self) -> Dict[str, Any]:
        """Get comprehensive system health summary"""
        with self.lock:
            component_statuses = {}
            overall_status = HealthStatus.HEALTHY

            for component_id, health in self.current_health.items():
                component_statuses[component_id] = {
                    "status": health.status.value,
                        "type": health.component_type.value,
                        "response_time_ms": health.response_time_ms,
                        "error_count": health.error_count,
                        "success_count": health.success_count,
                        "last_check": health.last_check.isoformat(),
                        "metrics": [
                        {
                            "name": m.name,
                                "value": m.value,
                                "unit": m.unit,
                                "status": (
                                "critical"
                                if m.threshold_critical
                                and m.value >= m.threshold_critical
                                else (
                                    "warning"
                                    if m.threshold_warning
                                    and m.value >= m.threshold_warning
                                    else "normal"
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                                 )
# BRACKET_SURGEON: disabled
#                             ),
# BRACKET_SURGEON: disabled
#                                 }
                        for m in health.metrics
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                     ],
# BRACKET_SURGEON: disabled
#                         }

                # Determine overall status
                if health.status == HealthStatus.CRITICAL:
                    overall_status = HealthStatus.CRITICAL
                elif (
                    health.status == HealthStatus.WARNING
                    and overall_status != HealthStatus.CRITICAL
# BRACKET_SURGEON: disabled
#                 ):
                    overall_status = HealthStatus.WARNING

            active_alerts = [
                {
                    "alert_id": alert.alert_id,
                        "component_id": alert.component_id,
                        "severity": alert.severity.value,
                        "message": alert.message,
                        "created_at": alert.created_at.isoformat(),
                        "acknowledged": alert.acknowledged,
# BRACKET_SURGEON: disabled
#                         }
                for alert in self.active_alerts.values()
                if not alert.resolved_at
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#             ]

            return {
                "overall_status": overall_status.value,
                    "monitoring_active": self.monitoring_active,
                    "total_components": len(self.current_health),
                    "healthy_components": sum(
                    1
                    for h in self.current_health.values()
                    if h.status == HealthStatus.HEALTHY
# BRACKET_SURGEON: disabled
#                 ),
                    "components": component_statuses,
                    "active_alerts": active_alerts,
                    "alert_counts": {
                    "critical": sum(
                        1 for a in active_alerts if a["severity"] == "critical"
# BRACKET_SURGEON: disabled
#                     ),
                        "warning": sum(
                        1 for a in active_alerts if a["severity"] == "warning"
# BRACKET_SURGEON: disabled
#                     ),
                        "info": sum(1 for a in active_alerts if a["severity"] == "info"),
# BRACKET_SURGEON: disabled
#                         },
                    "last_update": datetime.now().isoformat(),
# BRACKET_SURGEON: disabled
#                     }


    def acknowledge_alert(self, alert_id: str):
        """Acknowledge an alert"""
        with self.lock:
            if alert_id in self.active_alerts:
                self.active_alerts[alert_id].acknowledged = True

                # Update database
                try:
                    with sqlite3.connect(self.db_path) as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE health_alerts SET acknowledged = TRUE WHERE alert_id = ?",
                                (alert_id,),
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                                 )
                        conn.commit()
                except Exception as e:
                    logger.error(f"Failed to acknowledge alert: {e}")


    def resolve_alert(self, alert_id: str):
        """Resolve an alert"""
        with self.lock:
            if alert_id in self.active_alerts:
                self.active_alerts[alert_id].resolved_at = datetime.now()

                # Update database
                try:
                    with sqlite3.connect(self.db_path) as conn:
                        cursor = conn.cursor()
                        cursor.execute(
                            "UPDATE health_alerts SET resolved_at = CURRENT_TIMESTAMP WHERE alert_id = ?",
                                (alert_id,),
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#                                 )
                        conn.commit()
                except Exception as e:
                    logger.error(f"Failed to resolve alert: {e}")


    def shutdown(self):
        """Shutdown health monitoring"""
        logger.info("Shutting down health monitoring...")
        self.stop_monitoring()
        self.executor.shutdown(wait = True)
        logger.info("Health monitoring shutdown complete")

# Global instance
_global_monitor = None


def get_health_monitor() -> ComprehensiveHealthMonitor:
    """Get global health monitor instance"""
    global _global_monitor
        if _global_monitor is None:
            pass
        _global_monitor = ComprehensiveHealthMonitor()
    return _global_monitor

# Alert handler examples


def console_alert_handler(alert: HealthAlert):
    """Simple console alert handler"""
    print(f"\\nðŸš¨ HEALTH ALERT [{alert.severity.value.upper()}] ðŸš¨")
    print(f"Component: {alert.component_id}")
    print(f"Message: {alert.message}")
    print(f"Time: {alert.created_at.strftime('%Y-%m-%d %H:%M:%S')}")
    print("-" * 50)


def log_alert_handler(alert: HealthAlert):
    """Log - based alert handler"""
    logger.warning(
        f"HEALTH_ALERT: [{alert.severity.value}] {alert.component_id}: {alert.message}"
# FIXIT: commented possible stray closer
# FIXIT: commented possible stray closer
#     )

if __name__ == "__main__":
    # Example usage


    async def main():
        monitor = ComprehensiveHealthMonitor()

        # Add alert handlers
        monitor.add_alert_handler(console_alert_handler)
        monitor.add_alert_handler(log_alert_handler)

        # Start monitoring
        monitor.start_monitoring()

        # Let it run for a bit
        await asyncio.sleep(10)

        # Get health summary
        summary = monitor.get_system_health_summary()
        print(json.dumps(summary, indent = 2))

        # Shutdown
        monitor.shutdown()

    asyncio.run(main())